<!doctype html>
<html lang="en">
<head>
  <!-- speed up CDN fetch for p5 -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js" as="script" crossorigin>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Portfolio of Owen Denver Emerson</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  html, body {
    height: 100%;
    width: 100%;
    font-family: 'IBM Plex Sans', 'Inter', system-ui, Arial, sans-serif;
    overflow: hidden;
    background: linear-gradient(to bottom, #bfe5ff 0%, #eaf7ff 80%);
  }
  /* --- CLOUDS --- */
  .cloud { position:absolute; height:16px; background:rgba(255,255,255,0.9); z-index:1; animation:float 40s linear infinite; }
  .cloud::before, .cloud::after { content:""; position:absolute; height:100%; background:inherit; }
  .cloud.small { top:8%; left:-20%; width:120px; animation-duration:38s; }
  .cloud.small::before { left:140px; width:80px; }
  .cloud.small::after { left:240px; width:60px; }
  .cloud.large { top:18%; left:-30%; width:180px; animation-duration:52s; animation-delay:-6s; }
  .cloud.large::before { left:200px; width:100px; }
  .cloud.large::after { left:320px; width:80px; }
  @keyframes float { from { transform: translateX(0); } to { transform: translateX(130vw); } }

  /* --- FOLDER STRUCTURE --- */
  .folder-back {
    position:absolute; bottom:0; left:0; width:100%; height:86%;
    background:linear-gradient(to bottom,#e9d79a 0%,#e2c97f 100%);
    z-index:2; border-top:2px solid rgba(0,0,0,0.12);
  }

  .paper {
    position:absolute; top:15%; left:0; width:100%; height:5%;
    background:#fff; z-index:3; border-top:1px solid rgba(0,0,0,0.1);
    border-bottom:1px solid rgba(0,0,0,0.1);
  }

  .folder-front {
    position:absolute; bottom:0; left:0; width:100%; top:20%;
    background:linear-gradient(to bottom,#f5e0a1 0%,#f2d58b 100%);
    z-index:4; border-top:2px solid rgba(0,0,0,0.2);
    display:flex; flex-direction:row; align-items:center; justify-content:flex-start;
    padding:0 5%;
  }

  /* --- CARD STACK --- */
  .card-stack {
    margin-left: auto;
    flex:0 0 26%;
    max-width:320px;
    aspect-ratio:3/4;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    z-index:6;
    perspective:1000px;
  }
  .card {
    position:absolute;
    width:100%; height:100%;
    border:2px solid rgba(0,0,0,0.1);
    background:#fff;
    display:flex; align-items:center; justify-content:center;
    transition:transform 0.6s ease, opacity 0.6s ease;
    will-change:transform, opacity;
  }
  .card img, .card video { width:100%; height:100%; object-fit:cover; pointer-events:none; user-select:none; }
  .card-stack .card:nth-child(1){ transform:translateY(0px) scale(1); z-index:3; }
  .card-stack .card:nth-child(2){ transform:translateY(8px) scale(0.97); z-index:2; }
  .card-stack .card:nth-child(3){ transform:translateY(16px) scale(0.94); z-index:1; }
  .card-stack:hover .card:nth-child(1){ transform:translateY(-4px) scale(1.02); }

  @media (max-width:900px){ .card-stack{ width:34%; } }
  @media (max-width:480px){
    .folder-front { flex-direction:column; align-items:center; }
    .card-stack { width:80%; margin-top:4%; margin-left:0; }
  }

  /* --- TABS --- */
  .tabs { position:absolute; top:6%; left:0; width:100%; display:flex; gap:1%; padding-left:2%; align-items:flex-end; z-index:5; }
  .tab { flex:0 0 18%; height:8vh; display:flex; align-items:center; justify-content:center;
         border:2px solid rgba(0,0,0,0.18); font-weight:700; letter-spacing:0.05em; text-transform:uppercase;
         cursor:pointer; transition:background 0.25s ease, transform 0.15s ease; border-radius:0 !important; }
  .tab button{ all:unset; width:100%; height:100%; text-align:center; cursor:pointer; border-radius:0 !important; }
  .tab.manila{ background:#f7e9b8; color:#3a2f09; }
  .tab.green{ background:#cfeec7; color:#1f4d2b; }
  .tab.pink{ background:#f7cfcf; color:#5a3131; }
  .tab:hover{ transform:translateY(-2px); } .tab:active{ transform:translateY(0); }

  /* --- P5 CANVAS POSITIONING (desktop) --- */
  #p5-holder {
    position: absolute;
    z-index: 8;
    pointer-events: none;
    left: 2%;
    top: 21%;
    width: 60%;
    transform-origin: top left;
    transform: scale(0.85);
  }
  canvas.p5Canvas {
    width: 100% !important;
    height: auto !important;
    pointer-events: auto !important;
  }

  /* --- GREEN TEXT BOX (desktop) --- */
  .green-text-box {
    position: absolute;
    left: 2%;
    top: 55%;
    width: 58%;
    background: #cfeec7;
    border: 2px solid #aac3a3;
    z-index: 5;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0.4em 0.6em;
  }
  .green-text-box span {
    font-family: 'IBM Plex Sans', monospace;
    font-size: 1.1rem;
    font-weight: 600;
    color: #1f4d2b;
    text-align: center;
    letter-spacing: 0.02em;
    text-shadow:
      1px 1px 1px rgba(173, 216, 230, 0.6),
      -1px -1px 1px rgba(152, 251, 152, 0.6),
      0 0 2px rgba(255, 255, 255, 0.4);
    white-space: normal;
    overflow-wrap: anywhere;
  }

  /* --- MOBILE: banner -> banner -> big card stack (all inside manila) --- */
  @media (max-width: 768px) {

    /* p5 banner full-width below the white seam */
    #p5-holder {
      position: relative;
      left: 0;
      top: auto;
      width: 90%;
      transform: none;
      margin: calc(20vh + 6px) auto 0 auto; /* sits at top of manila */
      z-index: 6;
      pointer-events: none;
    }

    canvas.p5Canvas {
      width: 100% !important;
      height: auto !important;
      display: block;
    }

    /* green banner below red banner, full width */
    .green-text-box {
      position: relative;
      top: auto;
      left: 0;
      width: calc(100% - 8%);
      margin: 2vh auto 0 auto;
      padding: 0.8em 1em;
      z-index: 6;
      text-align: center;
    }
    .green-text-box span {
      font-size: clamp(1rem, 3.0vw, 1.25rem);
      line-height: 1.25;
    }

    /* push card content inside manila below the two banners */
  .folder-front {
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 0 4%;

    /* Smoothly adapt the top padding:
       - Minimum 60px on small phones
       - Grows slightly with viewport width (20vw middle term)
       - Maximum 100px on large phones
    */
    padding-top: calc(25vw + clamp(60px, 20vw, 100px));
  }

    /* big, centered card stack */
  .card-stack {
    width: 90%;               /* reduced from 96% for better horizontal fit */
    max-width: 500px;         /* prevents overflow on larger phones */
    margin: 2vh auto 10vh;    /* extra bottom margin to clear blue border */
    transform: scale(0.7);    /* gently scale down to fit vertically */
    transform-origin: center top;
  }
  }

  /* --- PORTRAIT LOCK MESSAGE (unchanged) --- */
  @media screen and (max-width:900px) and (orientation:landscape){
    body::before{
      content:"FLIP THAT PHONE BACK AROUND, COWBOY! I disabled landscape view on this section because it was too glitchy. I am a bad programmer. Sorry.";
      position:fixed; top:0; left:0; width:100vw; height:100vh;
      background:linear-gradient(to bottom,#bfe5ff 0%,#eaf7ff 80%);
      color:#1e1e1e; font-family:'Inter',sans-serif; font-weight:600;
      letter-spacing:0.03em; display:flex; align-items:center; justify-content:center;
      text-align:center; font-size:1.15rem; text-shadow:0 1px 3px rgba(255,255,255,0.6);
      z-index:9999;
    }
  }

/* --- HOUSE IMAGE (updated placement) --- */
.house-image {
  position: absolute;
  right: 6%;
  bottom: calc(100% - var(--folder-back-top, 14vh)); 
  height: 15vh;
  z-index: 9;
  pointer-events: auto; /* <-- was none */
  cursor: pointer;
}
.house-image:active {
  transform: scale(0.96);
}

/* Ensures the house aligns to the top of the manila folder area */
.folder-back {
  --folder-back-top: 13.5vh; /* approximate offset from top of viewport */
}

@media (max-width: 768px) {
  .house-image {
    right: 4%;
    height: 10vh;
    bottom: calc(100% - var(--folder-back-top, 12.6vh));
  }
}





/* --- TONAL FLAT RETRO DARK MODE --- */
body.dark-mode {
  background: #000;
  color: #fff;
}

/* Sky / clouds */
body.dark-mode .cloud { background: #111; }

/* Folder layers */
body.dark-mode .folder-back {
  background: #111;
  border-top: 2px solid #fff;
}
body.dark-mode .folder-front {
  background: #1a1a1a;
  border-top: 2px solid #f5f5f5;
}

/* Paper */
body.dark-mode .paper {
  background:#222;
  border:2px solid #fff;
}

/* Text box */
body.dark-mode .green-text-box {
  background: #333;
  border: 2px solid #fff;
}
body.dark-mode .green-text-box span { color:#fff; }

/* Tabs */
body.dark-mode .tab.manila,
body.dark-mode .tab.green,
body.dark-mode .tab.pink {
  background:#1a1a1a;
  color:#fff;
  border:1px solid #fff;
}

/* Cards */
body.dark-mode .card {
  background:#222;
  border:2px solid #fff;
}

 */
body.dark-mode {
  background: linear-gradient(to bottom, #0d0d0d 0%, #1a1a1a 80%);
  color: #f5f5f5;
}

/* Clouds / sky */
body.dark-mode .cloud { background: rgba(255,255,255,0.15); }

/* Folder layers */
body.dark-mode .folder-back {
  background: linear-gradient(to bottom,#222,#111);
  border-top: 2px solid rgba(255,255,255,0.1);
}
body.dark-mode .folder-front {
  background: linear-gradient(to bottom,#333,#1f1f1f);
  border-top: 2px solid rgba(255,255,255,0.15);
}

/* Text + banners */
body.dark-mode .green-text-box {
  background: #222;
  border-color: #444;
}
body.dark-mode .green-text-box span { color:#fafafa; }

/* Tabs */
body.dark-mode .tab.manila { background:#2a2a2a; color:#eee; }
body.dark-mode .tab.green  { background:#1c1c1c; color:#ddd; }
body.dark-mode .tab.pink   { background:#202020; color:#ccc; }

/* Cards */
body.dark-mode .card { background:#181818; border-color:#444; }

/* Paper */
body.dark-mode .paper { background:#444; border-color:#666; }


#card-stack-wrapper { visibility: hidden; }
</style>

  <!-- Performance preloads -->
  <link rel="preload" href="my_assets/MoonTexture.jpg" as="image">
  <link rel="preload" href="my_assets/img1.jpg" as="image">
  <link rel="preload" href="my_assets/HeartSpinWebsite.mp4" as="image">
  <link rel="preload" href="my_assets/img2.png" as="image">
  <link rel="preload" href="my_assets/MSclip.mp4" as="image">
  <link rel="preload" href="my_assets/img3.png" as="image">


  <style>
  /* Skeleton shimmer placeholders */
  .skeleton {
    background: linear-gradient(90deg, #ccc 25%, #ddd 37%, #ccc 63%);
    background-size: 400% 100%;
    animation: shimmer 1.4s infinite;
  }
  @keyframes shimmer {
    0% { background-position: -400px 0; }
    100% { background-position: 400px 0; }
  }
  </style>

</head>

<body>
  <!-- Clouds -->
  <div class="cloud small" aria-hidden="true"></div>
  <div class="cloud large" aria-hidden="true"></div>

  <!-- Folder layers -->
  <div class="folder-back" aria-hidden="true"></div>

  <!-- House image sitting on top of the manila folder -->
  <img
  src="my_assets/Drawing (1).png"
  alt="House illustration"
  class="house-image" style="pointer-events:auto;cursor:pointer;"
  id="houseButton"
  onclick="toggleHouseImage()"
/>
<audio id="cricketsAudio" src="my_assets/classiccrickets.wav" loop></audio>

<div class="tabs">
  <a href="index.html" class="tab manila">Home</a>
  <a href="work.html" class="tab green">Work</a>
  <a href="contact.html" class="tab pink">About</a>
</div>
  <!-- SFX audio elements -->
  <audio id="clickSfx" src="my_assets/click.mp3" preload="auto"></audio>
  <audio id="doorbellSfx" src="my_assets/doorbell.mp3" preload="auto"></audio>
  <div class="paper" aria-hidden="true"></div>

  <!-- p5 sketch holder -->
  <div id="p5-holder"></div><!-- Green text box -->
  <div class="green-text-box">
    <span>...is telling Gen Z bedtime stories</span>
  </div>

  <!-- Folder front content -->
  <div class="folder-front">
    <div class="card-stack">
      <div class="card"><img src="my_homepage/img1.jpg" alt="Card 1"></div>
      <div class="card"><video src="my_homepage/HeartSpinWebsite.mp4" muted autoplay loop playsinline></video></div>
      <div class="card"><img src="my_homepage/img2.png" alt="Card 2"></div>
     <div class="card"><img src="my_homepage/img3.png" alt="Card 3"></div>
     <div class="card"><video src="my_homepage/MSclip.mp4" muted autoplay loop playsinline></video></div>
      <div class="card"><img src="my_homepage/img4.png" alt="Card 4"></div>
     <div class="card"><img src="my_homepage/img5.png" alt="Card 5"></div>
     <div class="card"><video src="my_homepage/houseshow.mp4" muted autoplay loop playsinline></video></div>
     <div class="card"><img src="my_homepage/img7.png" alt="Card 7"></div>
     <div class="card"><img src="my_homepage/img8.png" alt="Card 8"></div>
     <div class="card"><img src="my_homepage/img9.png" alt="Card 9"></div>
    </div>
  </div>

  <!-- p5 library -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>

  <!-- FULL p5 sketch (unchanged from your stable version) -->
  
  <!-- FULL p5 sketch (theme-aware) -->
  <script>
  let gridTex;
  let textLayer;
  let sphereDetail = 50;
  let autoRotate = 0;

  // Moon texture for dark mode
  let moonImg = null;
  let moonReady = false;

  // Smooth layout targets
  let targetRadius = 0;
  let targetSphereCX = 0;
  let radius = 0;
  let sphereCX = 0;

  // Theme helpers
  let lastDark = false;
let textDirty = true;
  function isDarkMode() {
    return document.body.classList.contains('dark-mode');
  }
  

function getTheme() {
  if (document.body.classList.contains('dark-mode')) {
    return {
      p5Bg: '#000000',
      frameStroke: '#ffffff',
      textOutline: [245,245,245],
      textFill: 255,
      glow: [[255,255,255],[230,230,230],[200,200,200]],
      sphereOutline: '#ffffff'
    };
  } else {
    return {
      p5Bg: '#f7cfcf',
      frameStroke: '#97717E',
      textOutline: [151,113,126],
      textFill: 255,
      glow: [[173,216,230],[152,251,152],[255,182,193]],
      sphereOutline: '#97717E'
    };
  }
}

  function preload() {}

function setup() {
    if (typeof pixelDensity === 'function') { try { pixelDensity(window.devicePixelRatio > 1 ? 1.5 : 1); } catch(e){} }
const aspectRatio = 0.25;
    const cnv = createCanvas(windowWidth, windowWidth * aspectRatio, WEBGL);
  const isiOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  try { document.createElement('canvas').getContext('2d'); } catch(e){}
  if (isiOS) { try { pixelDensity(1); } catch(e){} }
  const idle = isiOS ? (fn)=>setTimeout(fn,0) : (window.requestIdleCallback || ((fn)=>setTimeout(fn,0)));

  // Lazy-load moon texture (ensures it's ready in dark mode)
  
  idle(() => {
    try {
      loadImage('my_assets/MoonTexture.jpg', (img) => {
        moonImg = img;
        moonReady = true;
        if (typeof textDirty !== 'undefined') textDirty = true;
      }, () => { moonReady = false; });
    } catch (e) { moonReady = false; }
  });


  // Quicker first frame; restore quality shortly after
  sphereDetail = 24;
  setTimeout(() => { sphereDetail = 50; }, 800);

  // Lazy-load moon texture after first paint so the canvas can show immediately
  const __idle__ = window.requestIdleCallback || ((fn)=>setTimeout(fn, 0));
  __idle__(() => {
    try {
      loadImage('my_assets/MoonTexture.jpg',
        (img) => { moonImg = img; moonReady = true; },
        ()    => { moonReady = false; }
      );
    } catch(e){ moonReady = false; }
  });

  // Ensure text redraw after initial layout compute
  if (typeof textDirty !== 'undefined') { textDirty = true; }

    cnv.parent("p5-holder");
    setAttributes('alpha', true);
    noStroke();

    // Grid texture for sphere
    gridTex = createGraphics(384, 192);
    gridTex.clear();
    drawGridTexture(gridTex, isDarkMode());

    // Text layer
    textLayer = createGraphics(width, height);
    textLayer.pixelDensity(2); // restore clarity
    textLayer.clear();
    textLayer.pixelDensity(1);
    textLayer.clear();

    computeLayoutTargets();
    radius = targetRadius;
    sphereCX = targetSphereCX;
    updateTextLayer(radius, sphereCX);
  signalP5Ready();
  }

  function draw() {
    const theme = getTheme();
    background(theme.p5Bg);

    // Re-render grid texture only when theme flips
    const dark = isDarkMode();
    if (dark !== lastDark) {
      gridTex.clear();
      drawGridTexture(gridTex, dark);
      lastDark = dark;
    textDirty = true;
    }

    push();
    translate(-width / 2, 0, 0);

    autoRotate += 0.003;
    push();
    translate(sphereCX, 0, 0);
    const rotY = map(mouseX, 0, width, -PI, PI);
    const rotX = map(mouseY, 0, height, -PI / 2, PI / 2);
    rotateY(rotY + autoRotate);
    rotateX(rotX * 0.5);
    texture(dark && moonReady ? moonImg : gridTex);
    sphere(radius, sphereDetail, sphereDetail);
    pop();

    if (textDirty) { updateTextLayer(radius, sphereCX); textDirty = false; }
    image(textLayer, 0, -height / 2);
    pop();

    drawSphereOutline(radius);
    drawFrameOutline();
  }

  // ---------------- Layout + Scaling ----------------

  function computeLayoutTargets() {
    const baseScale = constrain(width / 900, 0.4, 1);
    let scaleFactor;
    if (width < 600)      scaleFactor = 1.05;
    else if (width < 1000) scaleFactor = 1.0;
    else if (width < 1400) scaleFactor = 0.9;
    else                   scaleFactor = 0.8;

    targetRadius = width * 0.12 * baseScale * scaleFactor;
    const offsetFactor = map(width, 320, 1400, 0.12, 0.17, true);
    targetSphereCX = targetRadius * (1 + offsetFactor);
  }

  // ---------------- Drawing helpers ----------------

  function drawSphereOutline(r) {
    const outlineColor = getTheme().sphereOutline;
    const cx = (width / 2) - (width / 2 - targetSphereCX);
    const cy = height / 2;
    const d = r * 2 * 1.06;
    const scaleW = constrain(width / 900, 0.4, 1);

    push();
    resetMatrix();
    translate(-width / 2, -height / 2);
    noFill();
    for (let i = 3; i >= 1; i--) {
      const w = (1 + i * 1.4) * scaleW;
      const a = 12 + i * 4;
      stroke(
        redFromHex(outlineColor),
        greenFromHex(outlineColor),
        blueFromHex(outlineColor),
        a
      );
      strokeWeight(w);
      ellipse(cx, cy, d + i * 2, d + i * 2);
    }
    stroke(outlineColor);
    strokeWeight(2.4 * scaleW);
    ellipse(cx, cy, d, d);
    pop();
  }

  function drawFrameOutline() {
    const theme = getTheme();
    push();
    resetMatrix();
    translate(-width / 2, -height / 2, 0);
    noFill();
    stroke(theme.frameStroke);
    strokeWeight(2);
    rect(0.5, 0.5, width - 3, height - 3);
    pop();
  }

  // ---------------- Color + Text ----------------
  function redFromHex(hex){ return parseInt(hex.slice(1,3), 16); }
  function greenFromHex(hex){ return parseInt(hex.slice(3,5), 16); }
  function blueFromHex(hex){ return parseInt(hex.slice(5,7), 16); }

function updateTextLayer(r = 0, sCX = 0) {
  const theme = getTheme();

  // Resize backing buffer if needed
  if (textLayer.width !== width || textLayer.height !== height) {
    textLayer.resizeCanvas(width, height);
  }
  textLayer.clear();
  textLayer.pixelDensity(1);              // avoids DPI-thick strokes on mobile

  const pastelColors = theme.glow;
  textLayer.textAlign(textLayer.LEFT, textLayer.CENTER);
  textLayer.textFont('IBM Plex Sans, monospace');

  const baseText = "wen Denver Emerson";

  // --- sizing the text ---
  const availableW = width - (sCX + r * 1.3);
  let fontSize = height * 1.0;            // your current starting point
  textLayer.textSize(fontSize);

  // Fit to available width (your current logic)
  let textW = textLayer.textWidth(baseText);
  if (textW > availableW) {
    fontSize *= (availableW / textW) * 0.95;
    textLayer.textSize(fontSize);
  }

  // ---------------------------
  // PROPORTIONAL STROKE WEIGHTS
  // ---------------------------
  // Scale stroke weights from font size, with sensible clamps
  const swGlow  = constrain(fontSize * 0.035, 0.7, 3.0);  // colored/white “halo” passes
  const swEdge  = constrain(fontSize * 0.070, 1.5, 6.0);  // main outline
  const swInner = constrain(fontSize * 0.020, 0.5, 2.4);  // optional inner sharpening

  // If you prefer even crisper edges on tiny screens, uncomment the next line:
  // const dpr = (window.devicePixelRatio || 1); const dprScale = Math.sqrt(dpr); swGlow/=dprScale; swEdge/=dprScale; swInner/=dprScale;

  const textStartX = sCX + r * 1.05;
  const baselineY  = height / 2;

  // Optional: crisper joins/caps for a “screen-printed” look
  textLayer.strokeJoin(textLayer.MITER);
  textLayer.strokeCap(textLayer.PROJECT);

  // --- iridescent/white halo passes (kept flat in dark mode) ---
  pastelColors.forEach((rgb, idx) => {
    textLayer.stroke(rgb[0], rgb[1], rgb[2], 220);
    textLayer.strokeWeight(swGlow);
    textLayer.noFill();
    textLayer.text(baseText, textStartX + idx * 0.6, baselineY + idx * 0.4);
  });

  // --- main outline ---
  textLayer.stroke(theme.textOutline[0], theme.textOutline[1], theme.textOutline[2]);
  textLayer.strokeWeight(swEdge);
  textLayer.noFill();
  textLayer.text(baseText, textStartX, baselineY);

  // (Optional) tiny inner pass to sharpen letterforms on small sizes
  // Comment out if you prefer the thicker single-outline look.
  // textLayer.stroke(theme.textFill);
  // textLayer.strokeWeight(swInner);
  // textLayer.noFill();
  // textLayer.text(baseText, textStartX, baselineY);

  // --- fill ---
  textLayer.noStroke();
  textLayer.fill(theme.textFill);
  textLayer.text(baseText, textStartX, baselineY);
}


  // ---------------- Grid texture ----------------
  function drawGridTexture(pg, dark=false) {
    if (dark) {
      pg.background(40);
      pg.stroke(190);
      pg.strokeWeight(1.5);
      for (let i = 0; i <= pg.width; i += pg.width / 12) {
        pg.stroke(190);
        pg.line(i, 0, i, pg.height);
      }
      for (let j = 0; j <= pg.height; j += pg.height / 6) {
        pg.stroke(120);
        pg.line(0, j, pg.width, j);
      }
      pg.stroke(190);
    } else {
      pg.background(255);
      pg.stroke('#c8b1b9');
      pg.strokeWeight(1.5);
      const colors = [ color(255,182,193), color(173,216,230), color(152,251,152) ];
      for (let i = 0; i <= pg.width; i += pg.width / 12) {
        const c = colors[int((i / (pg.width / 12)) % 3)];
        pg.stroke(c);
        pg.line(i, 0, i, pg.height);
      }
      for (let j = 0; j <= pg.height; j += pg.height / 6) {
        const c = colors[int((j / (pg.height / 6)) % 3)];
        pg.stroke(c);
        pg.line(0, j, pg.width, j);
      }
      pg.stroke('#c8b1b9');
    }
  }

  // ---------------- Resize ----------------
  function windowResized() {
    const aspectRatio = 0.25;
    resizeCanvas(windowWidth, windowWidth * aspectRatio);
    computeLayoutTargets();
    textDirty = true;
    // force refresh of grid when size changes
    gridTex.clear();
    drawGridTexture(gridTex, isDarkMode());
  }
  

function signalP5Ready() {
  document.body.dataset.p5ready = 'true';
  const wrapper = document.getElementById('card-stack-wrapper');
  if (wrapper) wrapper.style.visibility = 'visible';
}
</script>


  <!-- card stack animation -->
  <script>
  const stack = document.querySelector('.card-stack');
  let intervalTime = 4000;
  let lastTime = 0;

function cycleCards() {
  const cards = stack.querySelectorAll('.card');
  if (cards.length <= 1) return;
  const top = cards[0];
  const second = cards[1];

  // animate top card offscreen
  top.style.transform = 'translateX(110%) rotate(0deg)';
  top.style.opacity = '0';

  // bring next card to front
  second.style.transform = 'translateY(0) scale(1)';
  second.style.zIndex = cards.length;

  // re-stack the rest visually
  for (let i = 2; i < cards.length; i++) {
    const y = 8 * (i - 1);
    const scale = 1 - 0.03 * (i - 1);
    cards[i].style.transform = `translateY(${y}px) scale(${scale})`;
    cards[i].style.zIndex = cards.length - i;
  }

  setTimeout(() => {
    // Move top card to end and hide it behind others
    top.style.transition = 'none';
    const y = 8 * (cards.length - 1);
    const scale = 1 - 0.03 * (cards.length - 1);
    top.style.transform = `translateY(${y}px) scale(${scale})`;
    top.style.opacity = '0';             // keep hidden initially
    top.style.zIndex = 1;                // send to bottom
    stack.appendChild(top);

    // Force reflow and restore transition for future cycles
    void top.offsetWidth;
    top.style.transition = 'transform 0.6s ease, opacity 0.6s ease';

    // Fade it back in after re-insert (looks seamless)
    requestAnimationFrame(() => { top.style.opacity = '1'; });
  }, 600);
}


  function animationLoop(timestamp) {
    if (timestamp - lastTime >= intervalTime) {
      cycleCards();
      lastTime = timestamp;
    }
    requestAnimationFrame(animationLoop);
  }
  requestAnimationFrame(animationLoop);

  if (screen.orientation && screen.orientation.lock) {
    screen.orientation.lock('portrait').catch(() => {});
  }
  </script>
 







<script id="setCricketsVolumeOnLoad">
document.addEventListener('DOMContentLoaded', () => {
  const a = document.getElementById('cricketsAudio');
  if (a) a.volume = 0.35; // softer default volume
});
</script>


<script>
(function(){
  const SPRITES = {
    light: { normal: "my_assets/Drawing (1).png", click: "my_assets/Drawing (2).png" },
    dark:  { normal: "my_assets/Drawing (1)BW.png", click: "my_assets/Drawing (2)BW.png" }
  };

  function setHouseSpriteForMode() {
    const house = document.getElementById("houseButton");
    if (!house) return;
    const isDark = document.body.classList.contains("dark-mode");
    house.src = isDark ? SPRITES.dark.normal : SPRITES.light.normal;
  }

  window.toggleHouseImage = function toggleHouseImage() {
    const house = document.getElementById("houseButton");
    const audio = document.getElementById("cricketsAudio");
    const isDark = document.body.classList.contains("dark-mode");

    // Show press animation sprite based on current mode
    house.src = isDark ? SPRITES.dark.click : SPRITES.light.click;

    // After 1s, toggle mode, then set resting sprite based on NEW mode
    setTimeout(() => {
      const nowDark = document.body.classList.toggle("dark-mode");

      // handle audio playback
      if (audio) {
        try {
          if (nowDark) {
            audio.currentTime = 0;
            audio.play();
          } else {
            audio.pause();
            audio.currentTime = 0;
          }
        } catch(e){}
      }

      // set sprite for the resulting mode
      house.src = nowDark ? SPRITES.dark.normal : SPRITES.light.normal;
    }, 1000);
  };

  document.addEventListener("DOMContentLoaded", setHouseSpriteForMode);
})();
</script>


<script id="preloadHouseSprites">
document.addEventListener('DOMContentLoaded', () => {
  const sources = [
    "my_assets/Drawing (1).png",
    "my_assets/Drawing (2).png",
    "my_assets/Drawing (1)BW.png",
    "my_assets/Drawing (2)BW.png"
  ];
  sources.forEach(src => {
    const img = new Image();
    img.src = src;
  });
});
</script>





<script id="toggleHouseHandler">
function toggleHouseImage() {
  const house = document.getElementById("houseButton");
  const body  = document.body;
  const door  = document.getElementById("doorbellSfx");
  const audio = document.getElementById("cricketsAudio");

  // Play doorbell immediately on user gesture (do not await).
  try {
    if (door) { door.currentTime = 0; door.play().catch(()=>{}); }
  } catch(_) {}

  // SPRITES (supports BW in dark mode if present elsewhere)
  const isDark = body.classList.contains("dark-mode");
  const SPRITES = {
    light: { normal: "my_assets/Drawing (1).png",   click: "my_assets/Drawing (2).png" },
    dark:  { normal: "my_assets/Drawing (1)BW.png", click: "my_assets/Drawing (2)BW.png" }
  };

  if (house) house.src = isDark ? SPRITES.dark.click : SPRITES.light.click;

  setTimeout(() => {
    const nowDark = body.classList.toggle("dark-mode");

    // set resting sprite based on new mode
    if (house) house.src = nowDark ? SPRITES.dark.normal : SPRITES.light.normal;

    // crickets
    if (audio) {
      try {
        if (nowDark) { audio.currentTime = 0; audio.play(); }
        else { audio.pause(); audio.currentTime = 0; }
      } catch(_) {}
    }
  }, 1000);
}
</script>


<script id="tabClickSfx">
(function(){
  const clickSfx = document.getElementById('clickSfx');
  const anchors  = document.querySelectorAll('.tabs a');

  function stopAllSfx(){
    [clickSfx, document.getElementById('doorbellSfx')].forEach(a => {
      if (a){ try { a.pause(); a.currentTime = 0; } catch(_){} }
    });
  }

  // Stop sounds when page is hidden/unloaded (prevents BFCache replay)
  window.addEventListener('pagehide', stopAllSfx);
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') stopAllSfx();
  });
  window.addEventListener('pageshow', () => stopAllSfx());

  anchors.forEach(a => {
    a.addEventListener('click', (e) => {
      if (e.defaultPrevented) return;
      if (e.button !== 0) return;
      if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) return;
      e.preventDefault();
      const href = a.getAttribute('href');

      let navigated = false;
      const go = () => { if (!navigated) { navigated = true; window.location.href = href; } };

      // Try to play the click; navigate shortly after or when promise settles
      if (clickSfx) {
        try {
          clickSfx.currentTime = 0;
          const p = clickSfx.play();
          // Navigate when audio starts or after a short fallback delay
          if (p && typeof p.then === 'function') {
            p.then(() => setTimeout(go, 120)).catch(() => setTimeout(go, 80));
          } else {
            setTimeout(go, 120);
          }
        } catch(_) {
          setTimeout(go, 80);
        }
      } else {
        go();
      }
    }, { capture: true });
  });
})();
</script>





<script id="skeletonHelper">
document.addEventListener('DOMContentLoaded', () => {
  const kill = (id) => { const el = document.getElementById(id); if (el) el.remove(); };
  const waitCanvas = () => {
    const canvas = document.querySelector('canvas.p5Canvas');
    if (canvas) { kill('p5-skeleton'); }
    else { requestAnimationFrame(waitCanvas); }
  };
  waitCanvas();
  // card skeleton clears after first layout
  window.addEventListener('load', () => setTimeout(() => kill('card-skeleton'), 500));
});
</script>


<!-- Injected: persistent dark mode + crickets playback -->
<script>
// === Unified Dark Mode + Crickets Persistence System ===

// Apply saved state on load
document.addEventListener("DOMContentLoaded", () => {
  const isDark = localStorage.getItem("darkModeEnabled") === "true";
  const cricketsShouldPlay = localStorage.getItem("cricketsPlaying") === "true";
  if (isDark) document.body.classList.add("dark-mode");
  if (typeof window.setHouseSpriteForMode === "function") window.setHouseSpriteForMode();
  const crickets = document.getElementById("cricketsAudio");
  if (crickets && cricketsShouldPlay) {
    try { crickets.volume = 0.35; crickets.play(); } catch(e){}
  }
});

(function(){
  const SPRITES = {
    light: { normal: "my_assets/Drawing (1).png", click: "my_assets/Drawing (2).png" },
    dark:  { normal: "my_assets/Drawing (1)BW.png", click: "my_assets/Drawing (2)BW.png" }
  };

  function setHouseSpriteForMode() {
    const house = document.getElementById("houseButton");
    if (!house) return;
    const isDark = document.body.classList.contains("dark-mode");
    house.src = isDark ? SPRITES.dark.normal : SPRITES.light.normal;
  }
  window.setHouseSpriteForMode = setHouseSpriteForMode;

  window.toggleHouseImage = function toggleHouseImage() {
    const house = document.getElementById("houseButton");
    const crickets = document.getElementById("cricketsAudio");
    const doorbell = document.getElementById("doorbellSfx");
    const isDark = document.body.classList.contains("dark-mode");

    if (doorbell) { try { doorbell.currentTime = 0; doorbell.play(); } catch(e){} }

    if (house) house.src = isDark ? SPRITES.dark.click : SPRITES.light.click;

    setTimeout(() => {
      const nowDark = document.body.classList.toggle("dark-mode");
      if (crickets) {
        try {
          if (nowDark) { crickets.currentTime = 0; crickets.play(); }
          else { crickets.pause(); crickets.currentTime = 0; }
        } catch(e){}
      }
      // Persist both dark mode and crickets playback state
      localStorage.setItem("darkModeEnabled", document.body.classList.contains("dark-mode"));
      localStorage.setItem("cricketsPlaying", nowDark ? "true" : "false");

      if (house) house.src = nowDark ? SPRITES.dark.normal : SPRITES.light.normal;
    }, 1000);
  };

  document.addEventListener("DOMContentLoaded", setHouseSpriteForMode);
})();
</script>


<script id="defer-heavy-assets">
(function(){
  const videos = document.querySelectorAll('.card video');
  const imgs   = document.querySelectorAll('.card img');

  videos.forEach(v => {
    v.dataset.src = v.getAttribute('src');
    v.removeAttribute('src');
    v.preload = 'none';
  });

  imgs.forEach(img => {
    img.dataset.src = img.getAttribute('src');
    img.removeAttribute('src');
  });

  const observer = new MutationObserver(() => {
    if (document.body.dataset.p5ready === "true") {
      videos.forEach(v => {
        if (v.dataset.src) {
          v.src = v.dataset.src;
          v.load();
          v.play().catch(()=>{});
        }
      });
      imgs.forEach(img => {
        if (img.dataset.src) img.src = img.dataset.src;
      });
      observer.disconnect();
    }
  });

  observer.observe(document.body, { attributes:true, attributeFilter:['data-p5ready'] });
})();
</script>

</body>
</html>




